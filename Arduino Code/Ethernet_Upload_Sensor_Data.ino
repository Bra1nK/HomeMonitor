/*
Brian Kelly 11th March 2013 http://kellybk.com

This sketch uses the Ethernet shield to upload data from various
sensors and pulse counters to Emoncms. The original code is gleaned 
from various sources and modified.

I found DS1307 would only operate reliably from 5v whereas the
BMP085 requires 3.3v. Data from pulse counters is only uploaded
when sufficient pulses have been counted and the minimum time period
has elapsed. Other sensors just use minimum time period.
*/

#include <SPI.h>
#include <Ethernet.h>
#include <Wire.h>
#include <RTClib.h>

//Data Upload
static unsigned long MinPulseCount = 10;  // Minimum Pulses to Receive before data upload
static unsigned long MinElapsedTime = 60000;  // Minimum Seconds to elapse between data uploads

// Ethernet :-
// assign a MAC address for the ethernet controller.
// fill in your address here:
byte mac[] = {0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED};
// fill in an available IP address on your network here,
// for manual configuration:
IPAddress ip(192,168,2,50);

// fill in your Domain Name Server address here:
IPAddress myDns(192,168,2,1);

IPAddress server(192,168,2,100);    // RaspberryPi
//char server[] = "raspberrypi.kellybk.lan";  //'N.B. Only Works with FQDN so "raspberrypi" fails to resolve

// Initialize the Ethernet client library
// with the IP address and port of the server 
// that you want to connect to (port 80 is default for HTTP):
EthernetClient client;

// Real Time Clock :-
RTC_DS1307 RTC;

//BMP085 Pressure and Temperature :-
#define BMP085_ADDRESS 0x77  // I2C address of BMP085

const unsigned char OSS = 3;  // Oversampling Setting 1,2 or 3; bigger = more samples

// Calibration values
int ac1;
int ac2; 
int ac3; 
unsigned int ac4;
unsigned int ac5;
unsigned int ac6;
int b1; 
int b2;
int mb;
int mc;
int md;

// b5 is calculated in bmp085GetTemperature(...), this variable is also used in bmp085GetPressure(...)
// so ...Temperature(...) must be called before ...Pressure(...).
long b5; 

short temperature;
long pressure;

// to correct for station's height above sea level
// add 1000pa for each 100m above sea level
int HeightCorr = 940;

//
// Meter Pulse Detection
// Use interrupt to detect change on IR phototransistor
//

// PIN DEFINITIONS
int int0_pin = 2;              // Interrupt 0 on pin 2, input
int int1_pin = 3;              // Interrupt 1 on pin 3, input

// Delays
int gbounce_delay_ms = 2000;     // pulse is 2 to 40 seconds wide
int bounce_delay_ms = 100;     // pulse is 10ms wide

// Pulse Counters
unsigned long gcounter = 0;      // Nr of gas pulses seen
unsigned long gfirst_pulse_time = 0;
unsigned long glast_pulse_time = 0;
unsigned long counter = 0;      // Nr of electric pulses seen
unsigned long first_pulse_time = 0;
unsigned long last_pulse_time = 0;

// These are modified in the interrupts generated by pulse detection
volatile int gpulse_seen = 0;   // Gas pulse was seen in interrupt
volatile int pulse_seen = 0;   // Electric pulse was seen in interrupt

// Used by Power Calculations ..... Move to Emoncms ?
static unsigned long ms_per_hour = 3600000UL;  // ms per hour for power calcs
static float cal_value = 39.7;  // Joules per cc
static float corr_factor = 1.02264;

//Temperature Readings
int tempC;
int reading;
int tempPins[] = {2,3,4,5};
int PinCount = 4;
int PCount;

void setup()
{Serial.begin(9600);
    
//for BMP085
  Wire.begin();
  bmp085Calibration();
  
//for RTC
  RTC.begin();  
  if (! RTC.isrunning()) {
    Serial.println("RTC is NOT running!");
  }
  
 // Electric and Gas Pulse Detection
 // We want internal pullup enabled:
 pinMode(int1_pin, INPUT);
 pinMode(int0_pin, INPUT);
 
 // And set up the interrupt.
 // RISING: -pin- goes from low to high
 
 // When IR detected, gas detector emits 5V
 // Once per revolution of gas dial as mirror
 // in No 6 reflects IR back to detector
 attachInterrupt(1, gblink, RISING);
 
 // When pulsing electric meter LED 
 // Pulse detected, amplifier emits 5V
 attachInterrupt(0, blink, RISING);
 
 //For Analog Voltage Measurements
 analogReference(INTERNAL);
 //INTERNAL1V1 for Mega, INTERNAL for Uno etc
 //Sets analogue reference voltage to 1.1 volt 
 //for better accuracy with LM35 which outputs 1 volt at 100 degC
  
  // start the Ethernet connection:
  Ethernet.begin(mac,ip,myDns);
  // give the Ethernet shield a second to initialize:
  delay(1000);
  Serial.println("connecting...");
  // print the Ethernet board/shield's IP address:
  Serial.print("My IP address: ");
  Serial.println(Ethernet.localIP());
}

void loop()
{
 static unsigned long gavg_watts;        // average gas watt draw since startup
 unsigned long gdelta;            // Time since last gas interrupt
 static unsigned long avg_watts;        // average watt draw since startup
 unsigned long delta;            // Time since last interrupt
 int incoming_byte;
 DateTime now;
 
 //Data Uploads
static long lastgas;
static long lastelectric;
static long lasttemps;
static long lastpressure;
char strtemps[] = "Temperature";

 // IR pulse interrupt happened
 if (gpulse_seen == 1) {
   gcounter++;

   glast_pulse_time = millis();

   if (gcounter == 1 || gfirst_pulse_time == 0) // we were reset
     gfirst_pulse_time = glast_pulse_time;
     
  // Reset until next one.
   gpulse_seen = 0;
 }

 // LED pulse interrupt happened
 if (pulse_seen == 1) {
   counter++;

   last_pulse_time = millis();

   if (counter == 1 || first_pulse_time == 0) // we were reset
     first_pulse_time = last_pulse_time;

   // Reset until next one.
   pulse_seen = 0;
 }

//Gas
if( (long)( millis() - (lastgas + MinElapsedTime)) >= 0 && (gcounter >= MinPulseCount)) {
      // print the avg watt gas draw since last query
     gdelta = glast_pulse_time - gfirst_pulse_time;
     if (gdelta && gcounter) {
       gavg_watts = (gcounter - 1) * ms_per_hour * cal_value * corr_factor/ gdelta;
       now = RTC.now();
       sendData (now.unixtime(),"Gas_Useage",gavg_watts);
       sendData (now.unixtime(),"Gas_Pulses",gcounter);
       gcounter = 0;       
     }
     lastgas = millis();
}

//Electric
if( (long)( millis() - (lastelectric + MinElapsedTime)) >= 0 && (counter >= MinPulseCount)) {
     // print the avg electric watt draw since last query
     delta = last_pulse_time - first_pulse_time;
     if (delta && counter) {
       avg_watts = (counter - 1) * ms_per_hour / delta;
       now = RTC.now();
       sendData (now.unixtime(),"Electric_Useage",avg_watts);
       sendData (now.unixtime(),"Electric_Pulses",counter);
       counter = 0;       
     }
     lastelectric = millis();
}

//Pressure
if( (long)( millis() - (lastpressure + MinElapsedTime)) >= 0) {
      now = RTC.now();
      //check temperature first as result is used in pressure calculation
      temperature = bmp085GetTemperature(bmp085ReadUT());
      pressure = bmp085GetPressure(bmp085ReadUP()) + HeightCorr; // to correct for height above sea level       
      sendData (now.unixtime(),"Pressure",pressure);
      sendData (now.unixtime(),"Temperature1",temperature);
      lastpressure = millis();
}

//Temperatures
if( (long)( millis() - (lasttemps + MinElapsedTime)) >= 0) {
     now = RTC.now();
     for (PCount=0;PCount<PinCount;PCount++) {
       analogRead(tempPins[PCount]);  //switch ADC to tempPin
       delay(20);  //delay for ADC to stabilise
       reading = analogRead(tempPins[PCount]);  //Take Reading
       tempC = int(reading / 0.931);
       strtemps[11] = tempPins[PCount] + 48;
       strtemps[12] = '\0';     
       sendData (now.unixtime(),strtemps,tempC);
       }
       lasttemps = millis();
     }
     
 // Query exists on serial port; service it.
 if (Serial.available() > 0) {
   incoming_byte = Serial.read();
   Serial.flush();
   switch (incoming_byte) {
   
   case 's':
      now = RTC.now();
      //check temperature first as result is used in pressure calculation
      temperature = bmp085GetTemperature(bmp085ReadUT());
      pressure = bmp085GetPressure(bmp085ReadUP()) + HeightCorr; // to correct for height above sea level       
      sendData (now.unixtime(),"Pressure",pressure);
      sendData (now.unixtime(),"Temperature5",temperature);
      break;
      
   case 'i':
   //read BMP085 on I2C bus
   //check temperature first as result is used in pressure calculation
    temperature = bmp085GetTemperature(bmp085ReadUT());
    pressure = bmp085GetPressure(bmp085ReadUP()) + 940; // to correct for height above sea level  
    Serial.print("Temperature: ");
    Serial.print(temperature, DEC);
    Serial.println(" * 0.1 deg C");
    Serial.print("Pressure: ");
    Serial.print(pressure, DEC);
    Serial.println(" Pa");
    Serial.println();
    break;   
     
   case 'u':
   //Read RTC
    now = RTC.now();
    showDate("Now",now);
  
    break;
    
   case 't':
     //Serial.print("T");  // Start Marker
     // Retrieve Temperature Readings
     for (PCount=0;PCount<PinCount;PCount++) {
       analogRead(tempPins[PCount]);  //switch ADC to tempPin
       delay(20);  //delay for ADC to stabilise
       reading = analogRead(tempPins[PCount]);  //Take Reading
       tempC = reading / 9.31;
       Serial.print("Analog Pin ");
       Serial.print(tempPins[PCount]);
       Serial.print(" = ");     
       Serial.println(tempC);
       //if (PCount < PinCount-1){ 
       //Serial.print(",");
       //}
     }
     //Serial.print("E");  //End Marker
     break;
     
   case 'g':
     // print the avg watt gas draw since last query
     gdelta = glast_pulse_time - gfirst_pulse_time;
     if (gdelta && gcounter) {
       gavg_watts = (gcounter - 1) * ms_per_hour * cal_value * corr_factor/ gdelta;
       //gcounttot = gcounttot + gcounter;
       gcounter = 0;
     }
     //Start and End Markers added as some partial data was being received
     //Now base station can discard any data without valid delimeters
     Serial.print("G");  // Start Marker
     Serial.print(gavg_watts);
     Serial.print("L");  //End Marker
     break;
     
   case 'p':
     // print the avg electric watt draw since last query
     delta = last_pulse_time - first_pulse_time;
     if (delta && counter) {
       avg_watts = (counter - 1) * ms_per_hour / delta;
       //counttot = counttot + counter;
       counter = 0;
     }
     //Start and End Markers added as some partial data was being received
     //Now base station can discard any data without valid delimeters
     Serial.print("S");  // Start Marker
     Serial.print(avg_watts);
     Serial.print("E");  //End Marker
     break;
   default:
     break;
   }
 }
}

// Interrupt handler
//
// We get here for RISING; so when IR turns on.
//
void gblink()
{
 static unsigned long glast_interrupt_time = 0;
 unsigned long ginterrupt_time = millis();

 // If interrupts come faster than bounce_delay_ms, assume it's a bounce and ignore
 //
 // Note, millis() wraps every 50 days, be sure we cope...
 //
 if (ginterrupt_time - glast_interrupt_time > gbounce_delay_ms)
   gpulse_seen = 1;  // loop() sees pulse == 1 and takes action

 glast_interrupt_time = ginterrupt_time;
}

void blink()
{
 static unsigned long last_interrupt_time = 0;
 unsigned long interrupt_time = millis();

 // If interrupts come faster than bounce_delay_ms, assume it's a bounce and ignore
 //
 // Note, millis() wraps every 50 days, be sure we cope...
 //
 if (interrupt_time - last_interrupt_time > bounce_delay_ms)
   pulse_seen = 1;  // loop() sees pulse == 1 and takes action

 last_interrupt_time = interrupt_time;
}

// Stores all of the bmp085's calibration values into global variables
// Calibration values are required to calculate temp and pressure
// This function should be called at the beginning of the program
void bmp085Calibration()
{
  ac1 = bmp085ReadInt(0xAA);
  ac2 = bmp085ReadInt(0xAC);
  ac3 = bmp085ReadInt(0xAE);
  ac4 = bmp085ReadInt(0xB0);
  ac5 = bmp085ReadInt(0xB2);
  ac6 = bmp085ReadInt(0xB4);
  b1 = bmp085ReadInt(0xB6);
  b2 = bmp085ReadInt(0xB8);
  mb = bmp085ReadInt(0xBA);
  mc = bmp085ReadInt(0xBC);
  md = bmp085ReadInt(0xBE);
}

// Calculate temperature given ut.
// Value returned will be in units of 0.1 deg C
short bmp085GetTemperature(unsigned int ut)
{
  long x1, x2;
  
  x1 = (((long)ut - (long)ac6)*(long)ac5) >> 15;
  x2 = ((long)mc << 11)/(x1 + md);
  b5 = x1 + x2;

  return ((b5 + 8)>>4);  
}

// Calculate pressure given up
// calibration values must be known
// b5 is also required so bmp085GetTemperature(...) must be called first.
// Value returned will be pressure in units of Pa.
long bmp085GetPressure(unsigned long up)
{
  long x1, x2, x3, b3, b6, p;
  unsigned long b4, b7;
  
  b6 = b5 - 4000;
  // Calculate B3
  x1 = (b2 * (b6 * b6)>>12)>>11;
  x2 = (ac2 * b6)>>11;
  x3 = x1 + x2;
  b3 = (((((long)ac1)*4 + x3)<<OSS) + 2)>>2;
  
  // Calculate B4
  x1 = (ac3 * b6)>>13;
  x2 = (b1 * ((b6 * b6)>>12))>>16;
  x3 = ((x1 + x2) + 2)>>2;
  b4 = (ac4 * (unsigned long)(x3 + 32768))>>15;
  
  b7 = ((unsigned long)(up - b3) * (50000>>OSS));
  if (b7 < 0x80000000)
    p = (b7<<1)/b4;
  else
    p = (b7/b4)<<1;
    
  x1 = (p>>8) * (p>>8);
  x1 = (x1 * 3038)>>16;
  x2 = (-7357 * p)>>16;
  p += (x1 + x2 + 3791)>>4;
  
  return p;
}

// Read 1 byte from the BMP085 at 'address'
char bmp085Read(unsigned char address)
{
  unsigned char data;
  
  Wire.beginTransmission(BMP085_ADDRESS);
  Wire.write(address);
  Wire.endTransmission();
  
  Wire.requestFrom(BMP085_ADDRESS, 1);
  while(!Wire.available())
    ;
    
  return Wire.read();
}

// Read 2 bytes from the BMP085
// First byte will be from 'address'
// Second byte will be from 'address'+1
int bmp085ReadInt(unsigned char address)
{
  unsigned char msb, lsb;
  
  Wire.beginTransmission(BMP085_ADDRESS);
  Wire.write(address);
  Wire.endTransmission();
  
  Wire.requestFrom(BMP085_ADDRESS, 2);
  while(Wire.available()<2)
    ;
  msb = Wire.read();
  lsb = Wire.read();
  
  return (int) msb<<8 | lsb;
}

// Read the uncompensated temperature value
unsigned int bmp085ReadUT()
{
  unsigned int ut;
  
  // Write 0x2E into Register 0xF4
  // This requests a temperature reading
  Wire.beginTransmission(BMP085_ADDRESS);
  Wire.write(0xF4);
  Wire.write(0x2E);
  Wire.endTransmission();
  
  // Wait at least 4.5ms
  delay(5);
  
  // Read two bytes from registers 0xF6 and 0xF7
  ut = bmp085ReadInt(0xF6);
  return ut;
}

// Read the uncompensated pressure value
unsigned long bmp085ReadUP()
{
  unsigned char msb, lsb, xlsb;
  unsigned long up = 0;
  
  // Write 0x34+(OSS<<6) into register 0xF4
  // Request a pressure reading w/ oversampling setting
  Wire.beginTransmission(BMP085_ADDRESS);
  Wire.write(0xF4);
  Wire.write(0x34 + (OSS<<6));
  Wire.endTransmission();
  
  // Wait for conversion, delay time dependent on OSS
  delay(2 + (3<<OSS));
  
  // Read register 0xF6 (MSB), 0xF7 (LSB), and 0xF8 (XLSB)
  Wire.beginTransmission(BMP085_ADDRESS);
  Wire.write(0xF6);
  Wire.endTransmission();
  Wire.requestFrom(BMP085_ADDRESS, 3);
  
  // Wait for data to become available
  while(Wire.available() < 3)
    ;
  msb = Wire.read();
  lsb = Wire.read();
  xlsb = Wire.read();
  
  up = (((unsigned long) msb << 16) | ((unsigned long) lsb << 8) | (unsigned long) xlsb) >> (8-OSS);
  
  return up;
}

//Send Data to Emoncms Server using json
void sendData(uint32_t UnixTime,char Item[25], long value){
      if (client.connect(server, 80)) {
        Serial.println("connecting...");
       // Make a HTTP request:
        client.print("GET /emoncms/input/post.json?time=");
        client.print(UnixTime);
        client.print("&json={");
        client.print(Item);
        client.print(":");
        client.print(value);
        client.println("}&apikey=94c73b894134c6840c830f5d586843ed HTTP/1.0");  //put your own apikey here
        client.println();
        showDate("Data from",UnixTime);
        Serial.print("Data Sent : ");
        Serial.print(Item);
        Serial.print(" = ");
        Serial.println(value);
          }
       else  {
        // if you couldn't make a connection:
        Serial.println("connection failed");
        Serial.println("disconnecting.");
             }    
      client.stop();  
  }
  
void showDate(const char* txt, const DateTime& dt) {
    Serial.print(txt);
    Serial.print(' ');
    Serial.print(dt.year(), DEC);
    Serial.print('/');
    Serial.print(dt.month(), DEC);
    Serial.print('/');
    Serial.print(dt.day(), DEC);
    Serial.print(' ');
    Serial.print(dt.hour(), DEC);
    Serial.print(':');
    Serial.print(dt.minute(), DEC);
    Serial.print(':');
    Serial.print(dt.second(), DEC);
    Serial.println();
}
